name: "Reusable Workflow to Build Mythfrontednd"

on:
  workflow_call:
    inputs:
      MYTHBRANCH:
        required: true
        type: string
        default: master
      DEBUGBUILD:
        required: true
        type: boolean
        default: false

jobs:
  build_mythtv:
    strategy:
      matrix:
        os: ['macos-11', 'macos-12', 'macos-13']
        arch: ['X86']
      fail-fast: false
    runs-on: ${{ matrix.os }}
    env:
      PYVERS: "311"
      PYDOTVERS: "3.11"
      DBVERS: "mysql8"
      COMPILER: "default"
    steps:
    - uses: actions/checkout@master
    # Make sure the@v0.4.1 matches the current version of the
    # action
    - uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SF_PRIV_KEY }}
    - name: "Unpack input variables"
      run: |
        echo "MYTHBRANCH=${{ inputs.MYTHBRANCH }}" >> $GITHUB_ENV
        echo "DEBUGBUILD=${{ inputs.DEBUGBUILD }}" >> $GITHUB_ENV
    - name: "Setup environemental variables"
      run: |
        BLD_FLGS="--repo-prefix=${GITHUB_WORKSPACE} --version=${MYTHBRANCH} --python-version=${PYVERS} --database-version=${DBVERS} --macports-clang=${COMPILER}"
        if [ $DEBUGBUILD == "true" ]; then
          BLD_FLGS="$BLD_FLGS --extra-conf-flags=--compile-type=debug"
        fi
        case $MYTHBRANCH in
          *fixes*)
            VERSNUM=${MYTHBRANCH#*/}
          ;;
          *master*)
            VERSNUM=34
          ;;
          *)
            echo "Bad MYTHVERS"
            exit 1
          ;;
        esac
        echo "BLD_FLGS=${BLD_FLGS}" >> $GITHUB_ENV
        echo "PKGARCH=$(/usr/bin/uname -m)" >> $GITHUB_ENV
        echo "OS_VERS=$(/usr/bin/sw_vers -productVersion)" >> $GITHUB_ENV
        echo "ARCH=$(/usr/bin/uname -m)" >> $GITHUB_ENV
        echo "CCACHE_DIR=$HOME/.ccache" >> $GITHUB_ENV
        echo "VERSNUM=${VERSNUM}" >> $GITHUB_ENV
    - name: Check ccache
      uses: actions/cache@v3
      with:
        path: ${{ env.CCACHE_DIR }}
        key: mythtv-ccache-${{ env.VERSNUM }}-${{ matrix.os }}-${{ matrix.arch }}-${{ github.sha }}
        restore-keys: mythtv-ccache-${{ env.VERSNUM }}-${{ matrix.os }}-${{ matrix.arch }}-
    - name: "Setup deployment variables"
      run: |
        # setup destination folders
        SF_PROJ_PATH="/home/frs/project/m/my/mythtvformacosx"
        SF_PATH="$SF_PROJ_PATH/v$VERSNUM"
        case $OS_VERS in
          10.15*)
            SF_PATH="$SF_PATH/macOS\ 10.15\ Catalina"
          ;;
          11*)
            SF_PATH="$SF_PATH/macOS\ 11\ Big\ Sur"
          ;;
          12*)
            SF_PATH="$SF_PATH/macOS\ 12\ Monterey"
          ;;
          13*)
            # Apparently the Ventura builders do not neet the escape "\"
            SF_PATH="$SF_PATH/macOS 13 Ventura"
          ;;
          *)
            SF_PATH="$SF_PROJ_PATH/debug"
          ;;
        esac

        # override destination if DEBUGBUILD is true
        if [ $DEBUGBUILD == "true" ]; then
          SF_PATH="$SF_PROJ_PATH/debug/"
        fi

        # check is we're ARM based
        case $ARCH in
          arm*)
            SF_PATH="$SF_PATH/ARM64/"
          ;;
        esac
        SF_ARCH_PATH="$SF_PATH/Archive/"
        echo "SF_PATH=$SF_PATH" >> $GITHUB_ENV
        echo "SF_ARCH_PATH=$SF_ARCH_PATH" >> $GITHUB_ENV
    - name: Install X11 dependencies on MacOS
      if: runner.os == 'macOS'
      run: |
        # this must be done before we remove homebrew in the macports Bootstrap phase
        brew install --cask xquartz
    - name: "Bootstrap MacPorts"
      run: |
        if hash port 2>/dev/null; then
          echo "Macport is already installed"
        else
          curl -LJO https://raw.githubusercontent.com/GiovanniBussi/macports-ci/master/macports-ci
          source ./macports-ci install
          echo "PKGMGR_INST_PATH=/opt/local" >> $GITHUB_ENV
          echo "PKGMGR_BIN_PATH=/opt/local/bin" >> $GITHUB_ENV
          # now remove homebrew to prevent python conflicts
          /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)" --force
        fi
    - name: "Install required ports"
      run: |
        sudo port -N install gsed ccache py${PYVERS}-ansible py${PYVERS}-virtualenv py${PYVERS}-pkgconfig
        sudo port select --set python python${PYVERS}
        sudo port select --set python3 python${PYVERS}
        sudo port select --set ansible py${PYVERS}-ansible
        sudo port select --set virtualenv virtualenv${PYVERS}
        export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/opt/local/lib/mysql8/pkgconfig/
        export MYSQLCLIENT_LDFLAGS=$(pkg-config --libs mysqlclient)
        export MYSQLCLIENT_CFLAGS=$(pkg-config --cflags mysqlclient)
        if [ $COMPILER != "default" ];then
          CLANG_PORT=${COMPILER//clang-mp/clang}
          sudo port install $CLANG_PORT
        fi
        git clone https://github.com/MythTV/ansible.git
        cd ansible
        ${PKGMGR_BIN_PATH}/ansible-playbook-${PYDOTVERS} mythtv.yml --extra-vars="ansible_python_interpreter=${PKGMGR_BIN_PATH}/python${PYDOTVERS} database_version=${DBVERS} install_qtwebkit=true" --limit=localhost
        echo "Cleaning up macports builds"
        # force ownership for the users ansible / mythtv temp directories (in case ansible sets these to root)
        sudo chown $(id -u):$(id -g) ~/.ansible
        sudo chown $(id -u):$(id -g) ~/.mythtv
        sudo rm -rf ${PKGMGR_INST_PATH}/var/macports/build/*
        sudo rm -rf ${PKGMGR_INST_PATH}/var/macports/distfiles/*
    - name: "Build MythTV with Plugins"
      run: |
        # First build with plugins
        export CCACHE_DIR=${{ env.CCACHE_DIR }}
        /bin/zsh ./compileMythfrontendAnsible.zsh $BLD_FLGS --build-plugins=true
        mkdir -p with_plugins
        ditto "$GITHUB_WORKSPACE/mythtv-${VERSNUM}/mythtv/mythtv/programs/mythfrontend/mythfrontend.app" with_plugins/mythfrontend.app
    - name: "Re-Build MythTV without Plugins"
      if: ${{ env.DEBUGBUILD == 'false' }}
      run: |
        # Now make it without plugins
        /bin/zsh ./compileMythfrontendAnsible.zsh $BLD_FLGS --build-plugins=false
        mkdir -p without_plugins
        ditto "$GITHUB_WORKSPACE/mythtv-${VERSNUM}/mythtv/mythtv/programs/mythfrontend/mythfrontend.app" without_plugins/mythfrontend.app
        echo "Cleaning up workspace"
        rm -Rf $GITHUB_WORKSPACE/mythtv-${VERSNUM}/mythtv
    - name: "Sign App Bundles"
      if: ${{ env.DEBUGBUILD == 'false' }}
      # Extract the secrets we defined earlier as environment variables
      env:
        MACOS_CERTIFICATE: ${{ secrets.PROD_MACOS_CERTIFICATE }}
        MACOS_CERTIFICATE_PWD: ${{ secrets.PROD_MACOS_CERTIFICATE_PWD }}
        MACOS_CERTIFICATE_NAME: ${{ secrets.PROD_MACOS_CERTIFICATE_NAME }}
        MACOS_CI_KEYCHAIN_PWD: ${{ secrets.PROD_MACOS_CI_KEYCHAIN_PWD }}
      run: |
        # Turn our base64-encoded certificate back to a regular .p12 file
        echo $MACOS_CERTIFICATE | base64 --decode > certificate.p12

        # We need to create a new keychain, otherwise using the certificate will prompt
        # with a UI dialog asking for the certificate password, which we can't
        # use in a headless CI environment
        if [ -f ~/Library/Keychains/build.keychain-db ]; then
          security delete-keychain build.keychain
        fi
        security create-keychain -p "$MACOS_CI_KEYCHAIN_PWD" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" build.keychain
        security import certificate.p12 -P "$MACOS_CERTIFICATE_PWD" -A -t cert -f pkcs12 -k build.keychain
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$MACOS_CI_KEYCHAIN_PWD" build.keychain

        echo "Code Sign App Bundles"
        for APP in "with_plugins/mythfrontend.app" "without_plugins/mythfrontend.app"
        do
          APP_FMWK_DIR=$APP/Contents/Frameworks
          APP_EXE_DIR=$APP/Contents/MacOS
          APP_PLUGINS_DIR=$APP/PlugIns/

          # Per the Apple developer notes on codesigning, you must codesign from the inside out
          # Search the Applocation for so
          echo "Codesigning sos"
          find $APP -name '*.so' -print0 |
            while IFS= read -r -d '' line; do
              /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue "$line"
            done
          # Search for dylibs
          echo "Codesigning dylibs"
          find $APP -name '*.dylib' -print0 |
            while IFS= read -r -d '' line; do
              /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue "$line"
            done
          # Now sign the all frameworks and QT packages in the Frameworks directory
          echo "Codesigning Frameworks"
          find "${FRAMEWORKS_DIR}" -depth -type d -name "*.framework" -or -name "*.dylib" -or -name "*.bundle" | sed -e "s/\(.*framework\)/\1\/Versions\/A\//"|
            while IFS= read -r -d '' line; do
              /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue "$line"
            done

          find $APP  -type f -print0 | xargs -0 file | grep executable |
            while IFS= read -r -d '' line; do
              /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue "$line"
            done

          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue $APP_FMWK_DIR/Qt*
          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue $APP_FMWK_DIR/*.framework
          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue $APP_FMWK_DIR/*.dylib

          # Next any files in the MacOS directory (binaries/scripts)
          echo "Codesigning Executables"
          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue $APP_EXE_DIR/python
          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue $APP_EXE_DIR/mythutil
          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue $APP_EXE_DIR/mythpreviewgen
          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist --continue $APP_EXE_DIR/mythfrontend

          # finally sign the application
          echo "Codesigning Application"
          /usr/bin/codesign --force -s "$MACOS_CERTIFICATE_NAME" -v --timestamp --options runtime --entitlements entitlement.plist $APP
          # verify that the codesigning took
          echo "Verifying code signing"
          /usr/bin/codesign --verify -vv --deep $APP

          # create file for submission
          /usr/bin/ditto -c -k --keepParent $APP $APP.zip
        done
    - name: "Notarize App Bundles"
      if: ${{ !contains(matrix.os, '10.15') && env.DEBUGBUILD == 'false' }}
      env:
        MACOS_CI_KEYCHAIN_PWD: ${{ secrets.PROD_MACOS_CI_KEYCHAIN_PWD }}
        PROD_MACOS_NOTARIZATION_APPLE_ID: ${{ secrets.PROD_MACOS_NOTARIZATION_APPLE_ID }}
        PROD_MACOS_NOTARIZATION_TEAM_ID: ${{ secrets.PROD_MACOS_NOTARIZATION_TEAM_ID }}
        PROD_MACOS_NOTARIZATION_PWD: ${{ secrets.PROD_MACOS_NOTARIZATION_PWD }}
      run: |
        # setup notarization keychain
        echo "Create keychain profile"
        security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" build.keychain
        xcrun notarytool store-credentials "notarytool-profile" --apple-id "$PROD_MACOS_NOTARIZATION_APPLE_ID" --team-id "$PROD_MACOS_NOTARIZATION_TEAM_ID" --password "$PROD_MACOS_NOTARIZATION_PWD"

        echo "Notarize Applications"
        for APP in "with_plugins/mythfrontend.app" "without_plugins/mythfrontend.app"
        do
          xcrun notarytool submit "$APP.zip" --keychain-profile "notarytool-profile" --wait
          xcrun stapler staple "$APP"
          rm "$APP.zip"
        done
    - name: "Generate the DMGs"
      if: ${{ env.DEBUGBUILD == 'false' }}
      run: |
        echo "Generating DMG for Application with plugins"
        APP="with_plugins/mythfrontend.app"
        FULLVERS=$($APP/Contents/MacOS/mythfrontend --version|grep "MythTV Version"|gsed "s/^.*Version : *//")
        VOL_NAME_WITH=MythFrontend-$ARCH-$OS_VERS-$FULLVERS-with-plugins
        hdiutil create -volname "$VOL_NAME_WITH" -srcfolder "$APP" -ov -format UDRO "$VOL_NAME_WITH"
        echo "DMG_WITH=$VOL_NAME_WITH.dmg" >> $GITHUB_ENV

        echo "Generating DMG for Application without plugins"
        APP="without_plugins/mythfrontend.app"
        VOL_NAME_WITHOUT=MythFrontend-$ARCH-$OS_VERS-$FULLVERS
        hdiutil create -volname "$VOL_NAME_WITHOUT" -srcfolder "$APP" -ov -format UDRO "$VOL_NAME_WITHOUT"
        echo "DMG_WITHOUT=$VOL_NAME_WITHOUT.dmg" >> $GITHUB_ENV
    - name: "Sign and Notarize the DMGs"
      if: ${{ !contains(matrix.os, '10.15') && env.DEBUGBUILD == 'false' }}
      env:
        MACOS_CERTIFICATE: ${{ secrets.PROD_MACOS_CERTIFICATE }}
        MACOS_CERTIFICATE_PWD: ${{ secrets.PROD_MACOS_CERTIFICATE_PWD }}
        MACOS_CERTIFICATE_NAME: ${{ secrets.PROD_MACOS_CERTIFICATE_NAME }}
        MACOS_CI_KEYCHAIN_PWD: ${{ secrets.PROD_MACOS_CI_KEYCHAIN_PWD }}
      run: |
        echo "Notarizing DMGS"
        # First with plugins
        echo "Codesigning $DMG_WITH"
        security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" build.keychain
        codesign --force --sign "$MACOS_CERTIFICATE_NAME" "$DMG_WITH"
        echo "Notarizing $DMG_WITH"
        xcrun notarytool submit "$DMG_WITH" --keychain-profile "notarytool-profile" --wait
        xcrun stapler staple "$DMG_WITH"

        # Next without plugins
        echo "Codesigning $DMG_WITHOUT"
        security unlock-keychain -p "$MACOS_CI_KEYCHAIN_PWD" build.keychain
        codesign --force --sign "$MACOS_CERTIFICATE_NAME" "$DMG_WITHOUT"
        echo "Notarizing $DMG_WITHOUT"
        xcrun notarytool submit "$DMG_WITHOUT" --keychain-profile "notarytool-profile" --wait
        xcrun stapler staple "$DMG_WITHOUT"
    - name: "Upload DMGs to SourceForge"
      if: ${{ env.DEBUGBUILD == 'false' }}
      run: |
        # Copy files to the archive dir first with git tag
        echo "Transmitting new dmg files"
        sh -c "scp -o StrictHostKeyChecking=no $DMG_WITH ${{ secrets.SF_LOGIN }}@frs.sourceforge.net:'$SF_ARCH_PATH'"
        sh -c "scp -o StrictHostKeyChecking=no $DMG_WITHOUT ${{ secrets.SF_LOGIN }}@frs.sourceforge.net:'$SF_ARCH_PATH'"
        # Next copy to the latest dir without the git version tag
        sh -c "scp -o StrictHostKeyChecking=no $DMG_WITH ${{ secrets.SF_LOGIN }}@frs.sourceforge.net:'$SF_PATH/MythFrontend-$ARCH-$OS_VERS-v$VERSNUM-with-plugins.dmg'"
        sh -c "scp -o StrictHostKeyChecking=no $DMG_WITHOUT ${{ secrets.SF_LOGIN }}@frs.sourceforge.net:'$SF_PATH/MythFrontend-$ARCH-$OS_VERS-v$VERSNUM.dmg'"
    - name: "DEBUG: Zip build dir and upload to SourceForge"
      if: ${{ env.DEBUGBUILD == 'true' }}
      run: |
        /usr/bin/ditto -c -k --keepParent $GITHUB_WORKSPACE/mythtv-${VERSNUM}/mythtv ${APP}_DEBUG.zip
        # send files via scp
        echo "Transmitting new dmg files"
        sh -c "scp -o StrictHostKeyChecking=no MythFrontend-$ARCH-$OS_VERS_DEBUG.zip ${{ secrets.SF_LOGIN }}@frs.sourceforge.net:'$SF_PATH/'"
        sh -c "scp -o StrictHostKeyChecking=no MythFrontend-$ARCH-$OS_VERS_DEBUG.zip ${{ secrets.SF_LOGIN }}@frs.sourceforge.net:'$SF_PATH/'"
    - name: "Clean up keychain, certificate, and ssh keys"
      if: ${{ always() }}
      continue-on-error: true
      run: |
        # for ephemeral runners, this stup is unnecessary...
        if [ $DEBUGBUILD == "false" ]; then
          security delete-keychain build.keychain
          rm certificate.p12
        fi
        rm -Rf ~/.ssh
